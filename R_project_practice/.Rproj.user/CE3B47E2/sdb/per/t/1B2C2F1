{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Práctica 2\"\nauthor: \"Análisis de Componentes principales\"\ndate: \"12 de marzo de 2017\"\noutput:\n  html_notebook:\n    number_sections: yes\n    theme: journal\n    toc: yes\n  pdf_document:\n    toc: yes\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n#Introducción\n\nEsta práctica consite en el análisis de componentes principales de tres conjuntos de datos (**ventas**, **sctkp**, **dowjones**). En estadística, el **Análisis de Componentes Principales** (en español *ACP*, en inglés, *PCA*) es una técnica utilizada para reducir la dimensionalidad de un conjunto de datos.\n\nTécnicamente, el ACP busca la proyección según la cual los datos queden mejor representados en términos de mínimos cuadrados. Convierte un conjunto de observaciones de variables posiblemente correlacionadas en un conjunto de valores de variables sin correlación lineal llamadas componentes principales.\n\nLos objetivos del Análisis de Componentes Principales son:  \n\n* Resumir la variación total en una __dimensión menor__.  \n* Identificar fuentes de variación __interpretables__.  \n* Explorar características __inesperadas__ de los datos.  \n\nEl ACP se emplea sobre todo en análisis exploratorio de datos y como herramienta de procesado inicial de los datos. El ACP comporta el cálculo de la descomposición en autovalores y autovectores de la matriz de covarianza, normalmente tras centrar los datos en la media de cada atributo. Las componentes principales están basadas en combinaciones lineales de los datos originales centrados $X-\\bar{x}$  \n\n***  \n> Nota\n\nEsta página web está escrita usando Markdown y es un [R Notebook](http://rmarkdown.rstudio.com). El notebook está creado con **R-Studio**, que utiliza *knitr* y *pandoc* para exportar el código a multiples formatos, entre ellos *.md*. Utilizando el botón *Code* situado en la parte superior derecha es posible descargar el archivo *.Rmd* y ejecutar los scripts mediante R-Studio desktop. Para ello es necesario tener instalados los paquetes:\n\n```\ninstall.packages(\"rmarkdown\")\ninstall.packages(\"installr\")\ninstall.packages(\"pandoc\")\n```\n  \n    \n***\n\n#Carga de datos\n\nEn primer lugar, se carga el archivo [**ventas.txt**](./ventas.txt)  a R-Studio. Debemos indicar previamente a R-Studio, cuál es el directorio de trabajo en el que estará localizado el archivo. \n\n```{r}\nventas = read.table('ventas.txt')\nshow(ventas)\n```\n  \nPara calcular el número de filas se puede emplear la función _\"nrow\"_.  \n\n```{r}\nn = nrow(ventas)\nprint(c('número de filas=',n))\n```\n\n***  \n\n#Descripción de los datos  \n\n\nSe crea el vector de **medias muestrales _m_**, redondeando a cuatro decimales. El vector de medias muestrales, dada una matriz de datos $X_{n \\times p} = (x_{ij})$, el vector de medias muestrales se calcula como:  \n  \n$\\bar{x} = \\frac{1}{n} X^T 1_n = (\\bar{x_j}:j=1,...,p)$ \n```{r}\nm = round(colMeans(ventas), digits = 4); \nround(m, digits = 4);\n```\n\ny la matriz de **covarianzas muestrales _S_** , que se calcula como:  \n  \n$S = \\frac{1}{n} X^TX-\\bar{x} \\bar{x}^T = (s_{jk}:j=1,...,p)$  \n```{r}\nS = cov(ventas); \nround(S, digits = 4);\n```\n\nSe calcula la **Variación Total**, utilizando la función $VT = traza(S)$, en la que se suma la diagonal principal de la matriz de covarianzas muestrales,\n\n```{r}\nvt.ventas= round(sum(diag(S)), digits = 4)\nvt.ventas\n```\n\nPara el cálculo posterior de las variables tipificadas, se calcula la raiz de la diagonal principal de matriz de covarianzas,\n\n```{r}\nround(sqrt(diag(S)), digits = 4)\n```\n\nAhora calculamos la **matriz de correlación _R_**,cuya diagonal principal será de unos. Si $D = diag(S)$ y $d = diag(D^{^-1/_2})$ entonces la matriz de correlaciones se calcularía como:  \n  \n    \n$R = D^{^-1/_2}\\times S \\times D^{^-1/_2} = S \\times dd^T = (r_{jk}=\\frac{s_{jk}}{\\sqrt{s_{jj}s_{kk}}})$   \n\n```{r}\nR = cor(ventas); \nround(R, digits = 4)\n```\n\nSe calculan las **correlaciones mínima y máxima**. Para la máxima  previamente se resta una matriz identidad de tamaño **n**, para que no se utilicen los valores iguales a uno,\n\n```{r}\nround(c(min(R),max(R - diag(ncol(ventas)))), digits = 4);\n```\n\n##Gráfico\n\nFinalmente, en este apartado de descripción de los datos, se genera un gráfico de tipo **Matriz de Nube Puntos** o *scatter plot matrix* usando la función *\"plot* con unos determinados parámetros opcionales de salida gráfica.\n\n```{r}\nplot(ventas,pch = 19,cex = 1,upper.panel = NULL,col = 'blue', \nmain = 'Datos de Ventas',cex.main = 1.4,gap = .15,cex.labels = 2,font.labels = 2)\n\n```\n  \n***  \n\n#Componentes principales \n\nEl software R-Studio incluye en el paquete *stats* la función *\"princomp\"*, que se utiliza en el análisis de componentes principales. Toma como argumento la matriz de datos y devuelve un vector con siete elementos como respuesta:\n\nElemento     |Descripción\n-------------|-----------\n$sdev        |Las desviaciones estándar de las componentes principales.\n$loadings    |Matiz de autovectores y matriz de proporciones\n$center      |Los valores medios que se restaron\n$scale       |Las escalas aplicadas a cada variable\n$n.obs       |El número de observaciones\n$scores      |Matriz de componentes principales (si es calculable)\n$call        |Llamada al nombre de la matriz de datos\n\nPuede consultarse la ayuda de esta función usando:\n```{r}\nhelp(\"princomp\");\n```\n  \n  \nSe, por tanto, este vector de **componentes principales** haciendo que muestre todos los elementos de la respuesta,\n```{r}\npc = princomp(ventas) \npc[1:7]\n```\n\nPara el cálculo de **varianzas _var_** ($\\sigma^2$) se puede utilizar el resultado de las desviaciones estandard, indicando el nombre del elemnto elevado al cuadrado, de la siguiente forma:\n\n```{r}\nvar = with(pc, sdev^2)\nround(var, digits = 4)\n```\n\nSe genera la variable _sc_ para utilizarlo en Análisis equivalentes, si se sustituye $S_c = \\frac{n}{n-1}*S$ cuasi-varianzas.\n\n```{r}\nsc = 1 - (1/n)\n\n```\nDe forma que la varianza equivalente y, por tanto, los **Autovalores _var.eq_** ($L_{p \\times 1}$) son:\n\n```{r}\nvar.eq = (1/sc)*var\nround(var.eq, digits = 4)\n```\n\nPara calcular los coeficientes de los **Autovectores _G_** ($G = (g_1,g_2,...,g_p)$) (transpuesta), \n\n```{r}\nG = with(pc, loadings)[,]\nround(G, digits = 4)\n```\n\nY para obtener la **matriz de componentes principales _scores_**:\n\n$Y = (X - 1_n \\bar{x}^T)\\times G$,  \n\n```{r}\nscores = data.frame(with(pc, scores));\nshow(scores)\n\n```\n\nEs necesario cambiar al signo tanto de **_G_** como de **_scores_**. A continuación, se muestra para la primera componente:\n \n```{r}\nG[,1] = -G[,1];\nround(G[,1], digits =  4)  \n```\n\n```{r}\nscores[,1] = -scores[,1]\nround(scores[,1], digits =  4) \n```\n\nEl siguiente paso será comprobar que la matriz de componentes principales cumple con las propiedades del teorema,\n\n* El vector de **medias muestrales _m.cp_**  ($\\bar{y}$) es igual a cero.  \n* La matriz de **covarianzas muestrales _S.cp_** ($S_y$) tiene como diagonal el vector de autovalores.\n* Las componentes son **incorreladas** de **media cero** y **decreciente de variabiliad**.\n\n```{r}\nm.cp = round(colMeans(scores), digits = 4)\nm.cp\n```\n\n```{r}\nS.cp= round(cov(scores), digits =  4)\nS.cp\n```\n\nOtra comprobación a realizar sobre la matriz de componentes principales es, calcular la **Variación Total _VT.cp_**, que también debe coincidir con la VT de los datos:  \n\n```{r}\nVT.cp = round(sum(diag(cov(scores))),digits = 4)\nVT.cp\n```\n\n##Gráfico Scatter plot\n\nSe genera un gráfico de Matriz de nube puntos (scatter plot matrix). Para ello, en primer lugar se extrae una variable *r* que es la dimensión de la matriz de componentes principales, en segundo lugar se utiliza la función *plot* con una serie de parámetros.\n```{r}\nr = with(scores, range(Comp.1));\n\nplot(scores, pch = 19, cex = 1.2, upper.panel = NULL, col = 'royalblue', main = 'ACP de Ventas', cex.main = 1.3,xlim = r, \nylim = r,gap = .15,cex.labels = 1.5,font.labels = 2)\n```\n\nPuede observarse en el gráfico, que prácticamente todos los valores se encuentran sobre una línea horizontal\n\n##Gráfico Coordenadas esféricas\n\n```{r}\nplot(scores/sqrt(var), pch = 19,cex = 1.2, upper.panel = NULL, col = 'mediumseagreen', main = 'Datos esféricos de Ventas',labels = paste0('esf.',c(1:5)),cex.main = 1.3, gap = .15,cex.labels = 1.5,\nfont.labels = 2)\n```\n\n\n***\n#Reducción de la dimensión\n\nEn este apartado se trabaja con el objetivo del ACP, la reducción de la dimensión para realizar el resumen de los datos.\nEn primer lugar, se calcula la proporción de variación y proporción acumulada, mostrándose luego en una única matriz de variación explicada.\n\n```{r}\nprop = S.cp/VT.cp; \nacum = cumsum(prop)\ntable = round(data.frame(S.cp,prop,acum, row.names =NULL ),digits = 4)\ncat('', sep = '\\n');\n\n```\n\n**Proporciones**\n```{r}\nprop\n```\n**Proporciones acumuladas**\n```{r}\nacum\n```\n**Matriz de proporción explicada**\n```{r}\nshow(table)\n```\n\n##Gráfico de pendiente (Screen plot)\n\n```{r}\nplot(pc, type = 'l', col = 'royalblue', \npch = 19, lwd = 2.5, cex = 1.5, \nmain = 'Gráfico de pendiente de autovalores',\nfont.lab = 2,\ncex.main = 1.3)\n```\nLa **reducción de la dimensión** sería de $q = 1$, ya que $Y1$ explica el 97,67% de la variación.\n\n***\n#Interpretación del análisis\n\n**Y1:  coeficientes constantes (aproximadamente)**\nvariación proporcional a nota media  \n  \n$Y1 =  -0.8661X_1-0.0772X_2-0.4939X_3- $   \n\n$\\frac{X1+X2+X3}{3}$\n\n**1/3 normalizado:**\n\n```{r}\n1/sqrt(3)\n```\n***\n```{r}\ncons = -colMeans(ventas) %*% G[,1]; \ncolnames(cons) = 'cons';\ncat('', sep = '\\n'); round(cons[,], d = 4);\n```\n\n```{r}\ncat('', sep = '\\n'); \nmat<-data.frame(pc.1 = round((1/sqrt(3))*(scores[,1] - cons), digits = 4), n.media = rowMeans(ventas))  \n\ncat('', sep = '\\n'); \nround(G[,2], digits = 4)\nshow(mat)\n```\n\n**Y2: Comparación comportamiento libro abierto - cerrado** \n\n```{r}\nround(G[,3], digits = 4)\n```\n\n\n> **Conclusión**:Conservar únicamente Y1\n\n***\n\n**Matriz de correlación** ( Ventas ; Y1 )\n\nMatriz de correlación entre los datos y las tres columnas de la matriz de componentes principales.\n```{r}\ncat('', sep = '\\n'); round(cor(data.frame(ventas,scores[,1:2]))[1:3,1:3], digits = 4) \n```\n\n## Gráfico ACP\n\nDiseño\n```{r}\nplot(scores, pch = 19, \ncol = 'mediumseagreen', cex = 1.4, \nxlim = r, ylim = r);\n\n#lineas de referencia\nabline(h = 0, v = 0, lty = '1373', col = 'black',lwd = 1);\n\n#identificar individuos\nlab = c(1:n); \ntext(scores, labels = lab, font = 2, col = 'navy',cex = 1.5, pos = 1) \n\n```\nGráfico final\n```{r}\n#seleccionar individuos\nlab.plot = rep('',n);  \nlab.plot[1] = 'Std.1   '\nlab.plot[c(2,28,66,81)] = paste0('Std.',c(2,28,66,81));\n\n# vectorizar cex, pch, col, y pos \ncex.plot = rep(1.4,n);\ncex.plot[c(1,2,28,66,81)] = 1.6;\npch.plot = rep(19,n);\npch.plot[c(1,2,28,66,81)] = 15;\ncol.plot = rep('mediumseagreen',n);\ncol.plot[c(1,2,28,66,81)] = 'orangered';\npos.plot = rep(1,n); \npos.plot[1] = 3;\n\nplot(scores, pch = pch.plot, col = col.plot, cex = cex.plot, xlim = r, ylim = r, col.lab = 'royalblue', font.lab = 2, cex.lab = 1.2)  ;\n#box(lwd = 2);\n\n#  líneas de referencia\nabline(h = 0, v = 0, lty = '1373', col = 'brown',lwd = 2) \npoints(.0,.0,pch = 16, cex = 1.2, col = 'firebrick1')\n\n# identificar individuos \ntext(scores, labels = lab.plot, font = 2, col = 'navy', cex = 1., pos = pos.plot) \n\ntitle('ACP de Ventas', col.main = 'Blue',cex.main = 1.2)\n```\nVuelta a ventas\n```{r}\ncat('',sep = '\\n'); round(G[,1:2], digits = 4);\ncat('',sep = '\\n'); ventas[c(1,2), ]\n\n```\n\n\n",
    "created" : 1489406496875.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3831812608",
    "id" : "1B2C2F1",
    "lastKnownWriteTime" : 1489418389,
    "last_content_update" : 1489418389663,
    "path" : "C:/Users/xvilan/Desktop/practicasADM/notebook.Rmd",
    "project_path" : null,
    "properties" : {
        "chunk_output_type" : "inline",
        "last_setup_crc32" : "5AFD4F18bb338d19"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}